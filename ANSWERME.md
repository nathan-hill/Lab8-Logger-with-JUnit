Tasks to answer in your own README.md that you submit on Canvas:

1.  See logger.log, why is it different from the log to console?
	
	console.log only provides output to the console,  there is no external storage and it can only be tracked at runtime.
	logger.log can be customized to suit the class of the project, utilizing differing levels of warnings from runtime to compile time.  
	There is also the ability to write to files for ease of organization so the programmer can understand when something went wrong
	
2.  Where does this line come from? FINER org.junit.jupiter.engine.execution.ConditionEvaluator logResult Evaluation of condition [org.junit.jupiter.engine.extension.DisabledCondition] resulted in: ConditionEvaluationResult [enabled = true, reason = '@Disabled is not present']

	
	

1.  What does Assertions.assertThrows do?

	Asserts that execution of the supplied executable throws an exception of the expectedType and returns the exception. If no exception is thrown, or if an          	exception of a different type is thrown, this method will fail. If you do not want to perform additional checks on the exception instance,simply ignore the 	return value.

1.  See TimerException and there are 3 questions
    1.  What is serialVersionUID and why do we need it? (please read on Internet)
    
    	Overview. Simply put, the serialVersionUID is a unique identifier for Serializable classes. This is used during the deserialization of an object, to ensure 		that a loaded class is compatible with the serialized object. If no matching class is found, an InvalidClassException is thrown.
    
    2.  Why do we need to override constructors?

		Both overriden constructors allow for more information to be gathered when the TimerException constructor is called.  the first overriden constructor using
		message as it only parameter gives the additional ability to get the exception message with getMessage().  The second with both message and cause gives the
		programmer the ability to learn the cause of the exception.  In the previous constructors there could be cases where the cause wasn't included in the 
		message generated by the constructor.

    3.  Why we did not override other Exception methods?	
    
    	The other Exception methods aren't used in the testing field so its unnecessary for us to implement them.  The given Exceptions we already have are more 		than enough to log and inform the programmer of existing problems.  These Exceptions are specifically tied to the Timer class so we only need to handle
    	the exceptions that can possibly be thrown by Timer.java
    
1.  The Timer.java has a static block static {}, what does it do? (determine when called by debugger)

	This Static block is initializing the logger for the program, there is even a catch block for if there is a failure to start a logger.  We need to use the 	
	static block at the start so before anything else is executed we create a logger to handle anything the program does after the first initialization

1.  What is README.md file format how is it related to bitbucket? (https://confluence.atlassian.com/bitbucketserver/markdown-syntax-guide-776639995.html)

	The format of README.md is Markdown,  this format allows for emphasized text, screen captures, and more.  The format itself gives the programmer the ability 
	to give more information to anyone reading their README and allow them to draw the readers eyes to important texts or sections.  Bitbucket can read Markdown 
	so formatting a README in .md gives more potent instructions and gives the developer a chance to thoroughly explain their project and also include links, images
	, and even show pull requests.

1.  Why is the test failing? what do we need to change in Timer? (fix that all tests pass and describe the issue)

	the test failOverTest is failing because the type of error thrown is incorrect, it expects a TimerException but a NullPointerException is thrown instead.  The 	issue that was causing the failure was the removal of null from a variable, specifically TimeNow.  There was an if statement that threw an exception that would 	would skip over the section of code that removed the null condition from TimeNow.  this was an issue because later in the code block TimeNow is used to tell 
	when an exception occurred.  By moving the setting of TimeNow to before the if statement that has the potential to throw an exception we don't have the issue of 
	trying to use a variable that is currently nulled out

1.  What is the actual issue here, what is the sequence of Exceptions and handlers (debug)

	To reiterate my answer from the previous question,  in the debugger we see that when we throw our exception we skip over the population of TimeNow.  It goes 	from the throw to the catch block immediately because thats how try/catch blocks are meant to work.  The order specifically goes the call to timeMe() which 	enters a try/catch block, there is an error since the value entered is less than zero so an error is thrown.  This error is thrown to finally since the first 
	catch handles an InterruptedException that can occur from another method called method which has the thrown exception of InterruptedException.  By entering 
	the finally block we use the variables specified, including the currently nulled out long TimeNow.  This throws a nullPointerException instead of an expected
	TimerException so our test fails.

1.  Make a printScreen of your eclipse JUnit5 plugin run (JUnit window at the bottom panel) 
1.  Make a printScreen of your eclipse Maven test run, with console
1.  What category of Exceptions is TimerException and what is NullPointerException

	NullPointerException is a runtime exception, TimerException is an Exception which is one level higher than NullPointerException.  this means that when 	TimerException is to be used it must be declared in a method's throw clause.  NullPointerException occurs at any point during the runtime

1.  Push the updated/fixed source code to your own repository.